// TrustMan.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
/******************************************************************************
Module:  AccessMaster.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#include <Windowsx.h>   
#include <ACLAPI.h>   
#include <ACLUI.h>
#include <LM.h>
#include <winspool.h>
#include "Resource.h"   

// Force linking against the ACLUI library   
#pragma comment(lib, "ACLUI.lib")

//////////////////////////////// chDIMOF Macro ////////////////////////////////


// This macro evaluates to the number of elements in an array. 
#define chDIMOF(Array) (sizeof(Array) / sizeof(Array[0]))

// Sets the dialog box icons
inline void chSETDLGICONS(HWND hwnd, int idi) {
    SendMessage(hwnd, WM_SETICON, TRUE, (LPARAM)
        LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
            MAKEINTRESOURCE(idi)));
    SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM)
        LoadIcon((HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
            MAKEINTRESOURCE(idi)));
}

/////////////////////////// Quick MessageBox Macro ////////////////////////////


inline void chMB(PCSTR s) {
    char szTMP[128];
    GetModuleFileNameA(NULL, szTMP, chDIMOF(szTMP));
    MessageBoxA(GetActiveWindow(), s, szTMP, MB_OK);
}


//////////////////////////// Assert/Verify Macros /////////////////////////////


inline void chFAIL(PSTR szMsg) {
    chMB(szMsg);
    DebugBreak();
}


// Put up an assertion failure message box.
inline void chASSERTFAIL(LPCSTR file, int line, PCSTR expr) {
    char sz[128];
    wsprintfA(sz, "File %s, line %d : %s", file, line, expr);
    chFAIL(sz);
}

/////////////////////////// chHANDLE_DLGMSG Macro /////////////////////////////


// The normal HANDLE_MSG macro in WindowsX.h does not work properly for dialog
// boxes because DlgProc return a BOOL instead of an LRESULT (like
// WndProcs). This chHANDLE_DLGMSG macro corrects the problem:
#define chHANDLE_DLGMSG(hwnd, message, fn)                 \
   case (message): return (SetDlgMsgResult(hwnd, uMsg,     \
      HANDLE_##message((hwnd), (wParam), (lParam), (fn))))

// Put up a message box if an assertion fails in a debug build.
#ifdef _DEBUG
#define chASSERT(x) if (!(x)) chASSERTFAIL(__FILE__, __LINE__, #x)
#else
#define chASSERT(x)
#endif


// Assert in debug builds, but don't remove the code in retail builds.
#ifdef _DEBUG
#define chVERIFY(x) chASSERT(x)
#else
#define chVERIFY(x) (x)
#endif

////////////////////////////// chINRANGE Macro ////////////////////////////////


// This macro returns TRUE if a number is between two others
#define chINRANGE(low, Num, High) (((low) <= (Num)) && ((Num) <= (High)))


typedef enum AM_SECURETYPE {
    AM_FILE = 0, AM_DIR, AM_SERVICE,
    AM_PRINTER, AM_REGISTRY, AM_SHARE,
    AM_PROCESS, AM_THREAD, AM_JOB,
    AM_SEMAPHORE, AM_EVENT, AM_MUTEX,
    AM_MAPPING, AM_TIMER, AM_TOKEN,
    AM_NAMEDPIPE, AM_ANONPIPE,
    AM_WINDOWSTATION, AM_DESKTOP
};

typedef struct _ObjEntry {
    AM_SECURETYPE  m_nSpecificType;
    SE_OBJECT_TYPE m_objType;
    PTSTR          m_pszComboText;
    PTSTR          m_pszUsageText;
    BOOL           m_fUseName;
    BOOL           m_fUseHandle;
    BOOL           m_fUsePID;
    BOOL           m_fIsChild;
    BOOL           m_fIsContainer;
} ObjEntry;

typedef struct _ObjInf {
    ObjEntry*   m_pEntry;
    HANDLE      m_hHandle;
    TCHAR       m_szName[1024];
    TCHAR       m_szObjectName[2048];
} ObjInf;

/////////////////////////////////////////////////////////////////////////////// 

class CSecurityInformation : public ISecurityInformation {

public:
	CSecurityInformation(ObjInf* pInfo, BOOL fBinary) {
		m_pInfo = pInfo;
		m_nRef = 1;
		m_fBinary = fBinary;
	}

private:
	static GUID m_guidNULL;
	static SI_ACCESS m_siAccessAllRights[][19];
	static SI_ACCESS m_siAccessBinaryRights[32];
	static SI_INHERIT_TYPE m_siInheritType[];

	ULONG    m_nRef;
	ObjInf*  m_pInfo;

	BOOL     m_fBinary;

public:
	HRESULT WINAPI QueryInterface(REFIID riid, PVOID* ppvObj);
	ULONG WINAPI AddRef();
	ULONG WINAPI Release();

private:
	HRESULT WINAPI GetObjectInformation(PSI_OBJECT_INFO pObjectInfo);
	HRESULT WINAPI GetSecurity(SECURITY_INFORMATION RequestedInformation,
		PSECURITY_DESCRIPTOR* ppSecurityDescriptor, BOOL fDefault);
	HRESULT WINAPI SetSecurity(SECURITY_INFORMATION SecurityInformation,
		PSECURITY_DESCRIPTOR pSecurityDescriptor);
	HRESULT WINAPI GetAccessRights(const GUID* pguidObjectType,
		DWORD dwFlags, // si_edit_audits, si_edit_properties 
		PSI_ACCESS* ppAccess, ULONG* pcAccesses, ULONG* piDefaultAccess);
	HRESULT WINAPI MapGeneric(const GUID* pguidObjectType,
		UCHAR* pAceFlags, ACCESS_MASK* pMask);
	HRESULT WINAPI GetInheritTypes(PSI_INHERIT_TYPE* ppInheritTypes,
		ULONG* pcInheritTypes);
	HRESULT WINAPI PropertySheetPageCallback(HWND hwnd, UINT uMsg,
		SI_PAGE_TYPE uPage);
};

GUID CSecurityInformation::m_guidNULL = GUID_NULL;


// Binary aces 
SI_ACCESS CSecurityInformation::m_siAccessBinaryRights[] = {
	{ &m_guidNULL, 0x0001, L"0000000000000001 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0002, L"0000000000000010 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0004, L"0000000000000100 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0008, L"0000000000001000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0010, L"0000000000010000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0020, L"0000000000100000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0040, L"0000000001000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0080, L"0000000010000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0100, L"0000000100000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0200, L"0000001000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0400, L"0000010000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x0800, L"0000100000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x1000, L"0001000000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x2000, L"0010000000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x4000, L"0100000000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x8000, L"1000000000000000 [Specific 15-0]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x010000, L"00000001 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x020000, L"00000010 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x040000, L"00000100 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x080000, L"00001000 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x100000, L"00010000 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x200000, L"00100000 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x400000, L"01000000 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x800000, L"10000000 [Standard 23-16]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x1000000, L"1 [SACL 24]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x2000000, L"1 [Maximum Allowed 25]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x4000000, L"01 [Reserved 27-26]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x8000000, L"10 [Reserved 27-26]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x10000000, L"0001 [Generic 31-28]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x20000000, L"0010 [Generic 31-28]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x40000000, L"0100 [Generic 31-28]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, 0x80000000, L"1000 [Generic 31-28]",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC }
};


/////////////////////////////////////////////////////////////////////////////// 


#define ACCESS_NULL_ENTRY NULL, 0, NULL, 0 
SI_ACCESS CSecurityInformation::m_siAccessAllRights[][19] = {

	{  // File (0) 
		{ &m_guidNULL, FILE_ALL_ACCESS, L"FILE_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, FILE_READ_DATA, L"FILE_READ_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_DATA, L"FILE_WRITE_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_APPEND_DATA, L"FILE_APPEND_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_READ_EA, L"FILE_READ_EA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_EA, L"FILE_WRITE_EA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_EXECUTE, L"FILE_EXECUTE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_READ_ATTRIBUTES, L"FILE_READ_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_ATTRIBUTES, L"FILE_WRITE_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Dir (14) 
		{ &m_guidNULL, FILE_ALL_ACCESS, L"FILE_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, FILE_LIST_DIRECTORY, L"FILE_LIST_DIRECTORY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_ADD_FILE, L"FILE_ADD_FILE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_ADD_SUBDIRECTORY, L"FILE_ADD_SUBDIRECTORY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_READ_EA, L"FILE_READ_EA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_EA, L"FILE_WRITE_EA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_TRAVERSE, L"FILE_TRAVERSE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_DELETE_CHILD, L"FILE_DELETE_CHILD",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_READ_ATTRIBUTES, L"FILE_READ_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_ATTRIBUTES, L"FILE_WRITE_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Service (29) 
		{ &m_guidNULL, SERVICE_ALL_ACCESS, L"SERVICE_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, SERVICE_CHANGE_CONFIG, L"SERVICE_CHANGE_CONFIG",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_ENUMERATE_DEPENDENTS,
	L"SERVICE_ENUMERATE_DEPENDENTS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_INTERROGATE, L"SERVICE_INTERROGATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_PAUSE_CONTINUE, L"SERVICE_PAUSE_CONTINUE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_QUERY_CONFIG, L"SERVICE_QUERY_CONFIG",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_QUERY_STATUS, L"SERVICE_QUERY_STATUS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_START, L"SERVICE_START",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_STOP, L"SERVICE_STOP",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SERVICE_USER_DEFINED_CONTROL,
	L"SERVICE_USER_DEFINED_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Printer (44) 
		{ &m_guidNULL, SERVER_ACCESS_ADMINISTER, L"SERVER_ACCESS_ADMINISTER",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, SERVER_ACCESS_ENUMERATE, L"SERVER_ACCESS_ENUMERATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PRINTER_ACCESS_ADMINISTER, L"PRINTER_ACCESS_ADMINISTER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PRINTER_ACCESS_USE, L"PRINTER_ACCESS_USE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, JOB_ACCESS_ADMINISTER, L"JOB_ACCESS_ADMINISTER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Registry (55) 
		{ &m_guidNULL, KEY_ALL_ACCESS, L"KEY_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, KEY_QUERY_VALUE, L"KEY_QUERY_VALUE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, KEY_SET_VALUE, L"KEY_SET_VALUE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, KEY_CREATE_SUB_KEY, L"KEY_CREATE_SUB_KEY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, KEY_ENUMERATE_SUB_KEYS, L"KEY_ENUMERATE_SUB_KEYS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, KEY_NOTIFY, L"KEY_NOTIFY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, KEY_CREATE_LINK, L"KEY_CREATE_LINK",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Share (68) 
		{ &m_guidNULL, PERM_FILE_READ, L"PERM_FILE_READ",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, PERM_FILE_WRITE, L"PERM_FILE_WRITE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PERM_FILE_CREATE, L"PERM_FILE_CREATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE", SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Process (74) 
		{ &m_guidNULL, PROCESS_ALL_ACCESS, L"PROCESS_TERMINATE",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, PROCESS_TERMINATE, L"PROCESS_TERMINATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_CREATE_THREAD, L"PROCESS_CREATE_THREAD",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_SET_SESSIONID, L"PROCESS_SET_SESSIONID",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_VM_OPERATION, L"PROCESS_VM_OPERATION",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_VM_READ, L"PROCESS_VM_READ",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_VM_WRITE, L"PROCESS_VM_WRITE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_DUP_HANDLE, L"PROCESS_DUP_HANDLE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_CREATE_PROCESS, L"PROCESS_CREATE_PROCESS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_SET_QUOTA, L"PROCESS_SET_QUOTA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_SET_INFORMATION, L"PROCESS_SET_INFORMATION",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, PROCESS_QUERY_INFORMATION, L"PROCESS_QUERY_INFORMATION",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE", SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Thread (91) 
		{ &m_guidNULL, THREAD_ALL_ACCESS, L"THREAD_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, THREAD_TERMINATE, L"THREAD_TERMINATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_SUSPEND_RESUME, L"THREAD_SUSPEND_RESUME",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_GET_CONTEXT, L"THREAD_GET_CONTEXT",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_SET_CONTEXT, L"THREAD_SET_CONTEXT",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_SET_INFORMATION, L"THREAD_SET_INFORMATION",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_QUERY_INFORMATION, L"THREAD_QUERY_INFORMATION",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_SET_THREAD_TOKEN, L"THREAD_SET_THREAD_TOKEN",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_IMPERSONATE, L"THREAD_IMPERSONATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, THREAD_DIRECT_IMPERSONATION,
	L"THREAD_DIRECT_IMPERSONATION",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Job (107) 
		{ &m_guidNULL, JOB_OBJECT_ALL_ACCESS, L"JOB_OBJECT_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, JOB_OBJECT_ASSIGN_PROCESS, L"JOB_OBJECT_ASSIGN_PROCESS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, JOB_OBJECT_SET_ATTRIBUTES, L"JOB_OBJECT_SET_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, JOB_OBJECT_QUERY, L"JOB_OBJECT_QUERY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, JOB_OBJECT_TERMINATE, L"JOB_OBJECT_TERMINATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, JOB_OBJECT_SET_SECURITY_ATTRIBUTES,
	L"JOB_OBJECT_SET_SECURITY_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE", SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Semaphore 
		{ &m_guidNULL, SEMAPHORE_ALL_ACCESS, L"SEMAPHORE_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, SEMAPHORE_MODIFY_STATE, L"SEMAPHORE_MODIFY_STATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Event 
		{ &m_guidNULL, EVENT_ALL_ACCESS, L"EVENT_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, EVENT_MODIFY_STATE, L"EVENT_MODIFY_STATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Mutex 
		{ &m_guidNULL, MUTEX_ALL_ACCESS, L"MUTEX_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, MUTEX_MODIFY_STATE, L"MUTEX_MODIFY_STATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Mapping 
		{ &m_guidNULL, FILE_MAP_COPY, L"FILE_MAP_COPY",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, FILE_MAP_WRITE, L"FILE_MAP_WRITE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_MAP_READ, L"FILE_MAP_READ",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_MAP_ALL_ACCESS, L"FILE_MAP_ALL_ACCESS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SECTION_EXTEND_SIZE, L"SECTION_EXTEND_SIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Timer 
		{ &m_guidNULL, TIMER_ALL_ACCESS, L"TIMER_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, TIMER_QUERY_STATE, L"TIMER_QUERY_STATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TIMER_MODIFY_STATE, L"TIMER_MODIFY_STATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Token 
		{ &m_guidNULL, TOKEN_ALL_ACCESS, L"TOKEN_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, TOKEN_ASSIGN_PRIMARY, L"TOKEN_ASSIGN_PRIMARY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_DUPLICATE, L"TOKEN_DUPLICATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_IMPERSONATE, L"TOKEN_IMPERSONATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_QUERY, L"TOKEN_QUERY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_QUERY_SOURCE, L"TOKEN_QUERY_SOURCE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_ADJUST_PRIVILEGES, L"TOKEN_ADJUST_PRIVILEGES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_ADJUST_GROUPS, L"TOKEN_ADJUST_GROUPS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_ADJUST_DEFAULT, L"TOKEN_ADJUST_DEFAULT",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, TOKEN_ADJUST_SESSIONID, L"TOKEN_ADJUST_SESSIONID",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Namedpipe 
		{ &m_guidNULL, FILE_ALL_ACCESS, L"FILE_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, FILE_READ_DATA, L"FILE_READ_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_DATA, L"FILE_WRITE_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_CREATE_PIPE_INSTANCE, L"FILE_CREATE_PIPE_INSTANCE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_READ_ATTRIBUTES, L"FILE_READ_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_ATTRIBUTES, L"FILE_WRITE_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Anonpipe 
		{ &m_guidNULL, FILE_ALL_ACCESS, L"FILE_ALL_ACCESS",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, FILE_READ_DATA, L"FILE_READ_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_DATA, L"FILE_WRITE_DATA",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_CREATE_PIPE_INSTANCE, L"FILE_CREATE_PIPE_INSTANCE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_READ_ATTRIBUTES, L"FILE_READ_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, FILE_WRITE_ATTRIBUTES, L"FILE_WRITE_ATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Windowstation 
		{ &m_guidNULL, WINSTA_ACCESSCLIPBOARD, L"WINSTA_ACCESSCLIPBOARD",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, WINSTA_ACCESSGLOBALATOMS, L"WINSTA_ACCESSGLOBALATOMS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_CREATEDESKTOP, L"WINSTA_CREATEDESKTOP",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_ENUMDESKTOPS, L"WINSTA_ENUMDESKTOPS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_ENUMERATE, L"WINSTA_ENUMERATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_EXITWINDOWS, L"WINSTA_EXITWINDOWS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_READATTRIBUTES, L"WINSTA_READATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_READSCREEN, L"WINSTA_READSCREEN",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WINSTA_WRITEATTRIBUTES, L"WINSTA_WRITEATTRIBUTES",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	},

	{  // Desktop 
		{ &m_guidNULL, DESKTOP_CREATEMENU, L"DESKTOP_CREATEMENU",
		SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
		{ &m_guidNULL, DESKTOP_CREATEWINDOW, L"DESKTOP_CREATEWINDOW",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_ENUMERATE, L"DESKTOP_ENUMERATE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_HOOKCONTROL, L"DESKTOP_HOOKCONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_JOURNALPLAYBACK, L"DESKTOP_JOURNALPLAYBACK",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_JOURNALRECORD, L"DESKTOP_JOURNALRECORD",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_READOBJECTS, L"DESKTOP_READOBJECTS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_SWITCHDESKTOP, L"DESKTOP_SWITCHDESKTOP",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DESKTOP_WRITEOBJECTS, L"DESKTOP_WRITEOBJECTS",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, READ_CONTROL, L"READ_CONTROL",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_DAC, L"WRITE_DAC",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, WRITE_OWNER, L"WRITE_OWNER",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, DELETE, L"DELETE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, SYNCHRONIZE, L"SYNCHRONIZE",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ &m_guidNULL, ACCESS_SYSTEM_SECURITY, L"ACCESS_SYSTEM_SECURITY",
	SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC },
	{ ACCESS_NULL_ENTRY }
	}
};



///////////////////////////////////////////////////////////////////////////////   


#ifndef UNICODE   
#error This module must be compiled natively using Unicode.   
#endif   

///////////////////////////////////////////////////////////////////////////////


class CPrintBuf {
public:
	CPrintBuf(SIZE_T nMaxSizeInBytes = 64 * 1024); // 64KB is default
	virtual ~CPrintBuf();

	BOOL Print(PCTSTR pszFmt, ...);
	BOOL PrintError(DWORD dwError = GetLastError());
	operator PCTSTR() { return(m_pszBuffer); }
	void Clear();

private:
	LONG Filter(EXCEPTION_POINTERS* pep);

private:
	int   m_nMaxSizeInBytes;
	int   m_nCurSize;
	PTSTR m_pszBuffer;
};


CPrintBuf::CPrintBuf(SIZE_T nMaxSizeInBytes) {

	// This constructor sets initial values of members, and reserves a block
	// of addresses of size nMaxSizeInBytes and commits a single page.
	m_nMaxSizeInBytes = nMaxSizeInBytes;
	m_nCurSize = 0;
	m_pszBuffer = (PTSTR)
		VirtualAlloc(NULL, m_nMaxSizeInBytes, MEM_RESERVE, PAGE_READWRITE);
	chASSERT(m_pszBuffer != NULL);
	chVERIFY(VirtualAlloc(m_pszBuffer, 1, MEM_COMMIT, PAGE_READWRITE) != NULL);
}


///////////////////////////////////////////////////////////////////////////////


CPrintBuf::~CPrintBuf() {

	VirtualFree(m_pszBuffer, 0, MEM_RELEASE);
}


///////////////////////////////////////////////////////////////////////////////


void CPrintBuf::Clear() {

	VirtualFree(m_pszBuffer, m_nMaxSizeInBytes, MEM_DECOMMIT);
	chVERIFY(VirtualAlloc(m_pszBuffer, 1, MEM_COMMIT, PAGE_READWRITE) != NULL);
	m_nCurSize = 0;
}


///////////////////////////////////////////////////////////////////////////////


LONG CPrintBuf::Filter(EXCEPTION_POINTERS* pep) {

	LONG lDisposition = EXCEPTION_EXECUTE_HANDLER;
	EXCEPTION_RECORD* per = pep->ExceptionRecord;
	__try {
		// Is exception is an access violation in the data buffer's region?
		if (per->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
			__leave;

		if (!chINRANGE(m_pszBuffer, (PVOID)per->ExceptionInformation[1],
			((PBYTE)m_pszBuffer) + m_nMaxSizeInBytes - 1)) {
			__leave;
		}

		// Attempt to commit storage to the region
		if (VirtualAlloc((PVOID)pep->ExceptionRecord->ExceptionInformation[1],
			1, MEM_COMMIT, PAGE_READWRITE) == NULL) {
			__leave;
		}

		lDisposition = EXCEPTION_CONTINUE_EXECUTION;
	}
	__finally {
	}
	return(lDisposition);
}


///////////////////////////////////////////////////////////////////////////////


int CPrintBuf::Print(PCTSTR pszFmt, ...) {

	// This function appends text to the formatted print buffer.
	int nLength = -1; // Assume failure
	va_list arglist;
	va_start(arglist, pszFmt);
	__try {
		// Append string to end of buffer
		nLength = _vstprintf(m_pszBuffer + m_nCurSize, pszFmt, arglist);
		if (nLength > 0)
			m_nCurSize += nLength;
	}
	__except (Filter(GetExceptionInformation())) {
		chMB("CPrintBuf attempted to go over the maximum size.");
		DebugBreak();
	}
	va_end(arglist);
	return(nLength);
}


///////////////////////////////////////////////////////////////////////////////


BOOL CPrintBuf::PrintError(DWORD dwErr) {

	// Append the last error string text to the buffer.
	PTSTR pszMsg = NULL;
	BOOL fOk = (0 != FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
		dwErr, 0, (PTSTR)&pszMsg, 0, NULL));
	fOk = fOk && (Print(TEXT("Error %d: %s"), dwErr, pszMsg) >= 0);
	if (pszMsg != NULL)
		LocalFree(pszMsg);
	return(fOk);
}

///////////////////////////////////////////////////////////////////////////////   


void ReportError(PTSTR szFunction, ULONG lErr) {

	CPrintBuf prntBuf;
	prntBuf.Print(TEXT("The Function:  %s\r\n"), szFunction);
	prntBuf.Print(TEXT("Caused the following error - \r\n"));
	prntBuf.PrintError(lErr);
	MessageBox(NULL, prntBuf, TEXT("AccessMaster Error"), MB_OK);
}


SI_INHERIT_TYPE CSecurityInformation::m_siInheritType[] = {
    { &m_guidNULL, CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE,
    TEXT("Child") },
    { &m_guidNULL, OBJECT_INHERIT_ACE | INHERIT_ONLY_ACE, TEXT("Child") }
};


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::QueryInterface(REFIID riid, PVOID* ppvObj) {

    HRESULT hr = E_NOINTERFACE;
    if ((riid == IID_ISecurityInformation) || (riid == IID_IUnknown)) {
        *ppvObj = this;
        AddRef();
        hr = S_OK;
    }
    return(hr);
}


///////////////////////////////////////////////////////////////////////////////   


ULONG CSecurityInformation::AddRef() {

    m_nRef++;
    return(m_nRef);
}


///////////////////////////////////////////////////////////////////////////////   


ULONG CSecurityInformation::Release() {

    ULONG nRef = --m_nRef;
    if (m_nRef == 0)
        delete this;
    return(nRef);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::GetObjectInformation(
    PSI_OBJECT_INFO pObjectInfo) {

    // We are doing both normal and advanced editing   
    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_ADVANCED;

    // Is it a container?   
    if (m_pInfo->m_pEntry->m_fIsContainer) {
        pObjectInfo->dwFlags |= SI_CONTAINER;
    }

    // Is it a child?   
    if (!m_pInfo->m_pEntry->m_fIsChild) {
        pObjectInfo->dwFlags |= SI_NO_ACL_PROTECT;
    }

    pObjectInfo->hInstance = GetModuleHandle(NULL);
    pObjectInfo->pszServerName = NULL;
    pObjectInfo->pszObjectName = m_pInfo->m_szObjectName;
    return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::GetSecurity(
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR* ppSecurityDescriptor, BOOL fDefault) {

    HRESULT hr = 1;
    PSECURITY_DESCRIPTOR pSD;

    // Get security information   
    ULONG lErr;
    if (m_pInfo->m_szName[0] != 0) // Is it named   
        lErr = GetNamedSecurityInfo(m_pInfo->m_szName,
            m_pInfo->m_pEntry->m_objType, RequestedInformation, NULL, NULL,
            NULL, NULL, &pSD);
    else // Is it a handle case   
        lErr = GetSecurityInfo(m_pInfo->m_hHandle, m_pInfo->m_pEntry->m_objType,
            RequestedInformation, NULL, NULL, NULL, NULL, &pSD);

    // No matter what we still display security information   
    if (lErr != ERROR_SUCCESS) { // Failure produces an empty SD   
        ReportError(TEXT("GetNamedSecurityInfo"), lErr);
        MessageBox(NULL, TEXT("An error occurred retrieving security ")
            TEXT("information for this object, \npossibly due to insufficient")
            TEXT(" access rights.  AccessMaster \nhas created an empty security")
            TEXT(" descriptor for editing."), TEXT("AccessMaster Notice"), MB_OK);
    }
    else {
        hr = S_OK;
        *ppSecurityDescriptor = pSD;
    }

    return(hr);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::GetAccessRights(const GUID* pguidObjectType,
    DWORD dwFlags, PSI_ACCESS* ppAccess, ULONG* pcAccesses,
    ULONG* piDefaultAccess) {

    // If the binary check box was set, we show only raw binary ACE information   
    if (m_fBinary) {

        *pcAccesses = 32;
        *ppAccess = m_siAccessBinaryRights;

    }
    else { // Otherwise locate the appropriate block of specific rights   

           // See AccessData.H header file   
        *ppAccess = m_siAccessAllRights[m_pInfo->m_pEntry->m_nSpecificType];
        *pcAccesses = 0;
        while ((*ppAccess)[*pcAccesses].mask != 0)
            (*pcAccesses)++;
        *piDefaultAccess = 0;
    }
    return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::MapGeneric(const GUID* pguidObjectType,
    UCHAR* pAceFlags, ACCESS_MASK* pMask) {
    return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::GetInheritTypes(PSI_INHERIT_TYPE* ppInheritTypes,
    ULONG* pcInheritTypes) {

    *pcInheritTypes = 1;
    // If it is a container pass static enherit information for containers   
    if (m_pInfo->m_pEntry->m_fIsContainer) {

        *ppInheritTypes = &(m_siInheritType[0]);

    }
    else { // If it is a child pass static enherit information for containers   

        if (m_pInfo->m_pEntry->m_fIsChild) {

            *ppInheritTypes = &(m_siInheritType[1]);

        }
        else { // If niether, no inheritance   

            *ppInheritTypes = NULL;
            *pcInheritTypes = 0;
        }
    }
    return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::PropertySheetPageCallback(HWND hwnd, UINT uMsg,
    SI_PAGE_TYPE uPage) {

    return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////   


HRESULT CSecurityInformation::SetSecurity(
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor) {

    HRESULT hr = 1;

    // Get the Dacl   
    PACL pDACL = NULL;
    BOOL fPresent, fDefaulted;
    GetSecurityDescriptorDacl(pSecurityDescriptor, &fPresent, &pDACL,
        &fDefaulted);

    // Get the SACL   
    PACL pSACL = NULL;
    GetSecurityDescriptorSacl(pSecurityDescriptor, &fPresent, &pSACL,
        &fDefaulted);

    // Get the owner   
    PSID psidOwner = NULL;
    GetSecurityDescriptorOwner(pSecurityDescriptor, &psidOwner, &fDefaulted);

    // Get the group   
    PSID psidGroup = NULL;
    GetSecurityDescriptorOwner(pSecurityDescriptor, &psidGroup, &fDefaulted);

    // Find out if DACL and SACL inherit from parent objects   
    SECURITY_DESCRIPTOR_CONTROL sdCtrl = NULL;
    ULONG ulRevision;
    GetSecurityDescriptorControl(pSecurityDescriptor, &sdCtrl, &ulRevision);
    if ((sdCtrl & SE_DACL_PROTECTED) != SE_DACL_PROTECTED)
        SecurityInformation |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    else
        SecurityInformation |= PROTECTED_DACL_SECURITY_INFORMATION;

    if ((sdCtrl & SE_SACL_PROTECTED) != SE_SACL_PROTECTED)
        SecurityInformation |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    else
        SecurityInformation |= PROTECTED_SACL_SECURITY_INFORMATION;

    // Set the security   
    ULONG lErr;
    if (m_pInfo->m_szName[0] != 0) // Is it named   
        lErr = SetNamedSecurityInfo(m_pInfo->m_szName,
            m_pInfo->m_pEntry->m_objType, SecurityInformation, psidOwner,
            psidGroup, pDACL, pSACL);
    else // Is it a handle case   
        lErr = SetSecurityInfo(m_pInfo->m_hHandle, m_pInfo->m_pEntry->m_objType,
            SecurityInformation, psidOwner, psidGroup, pDACL, pSACL);

    // Report error   
    if (lErr != ERROR_SUCCESS)
        ReportError(TEXT("GetNamedSecurityInfo"), lErr);
    else
        hr = S_OK;

    return(hr);
}




ObjEntry g_objMap[] = {
    { AM_TOKEN, SE_KERNEL_OBJECT, TEXT("Access Token"),
    TEXT("To view the access rights of an access token enter the ")
    TEXT("numerical value of its handle and process ID in the ")
    TEXT("\"Handle\" and \"PID/TID\" fields."),
    FALSE, TRUE, TRUE, FALSE, FALSE },
    { AM_ANONPIPE, SE_KERNEL_OBJECT, TEXT("Anonymous Pipe"),
    TEXT("To view the access rights of an Anonymous Pipe enter the ")
    TEXT("numerical value of its handle and process ID in the ")
    TEXT("\"Handle\" and \"PID/TID\" fields."),
    FALSE, TRUE, TRUE, FALSE, FALSE },
    { AM_DESKTOP, SE_WINDOW_OBJECT, TEXT("Desktop"),
    TEXT("To view the access rights of a Desktop object either enter ")
    TEXT("the Window Station and Desktop names in the \"Name\" field, ")
    TEXT("or the numerical value of its handle and process ID in the ")
    TEXT("\"Handle\" and \"PID/TID\" ")
    TEXT("fields.\r\nExample: \"Winsta0\\Default\""),
    TRUE, TRUE, TRUE, FALSE, FALSE },
    { AM_DIR, SE_FILE_OBJECT, TEXT("Directory"),
    TEXT("To view the access rights of a directory enter the fully ")
    TEXT("qualified path in the \"Name\" field."),
    TRUE, FALSE, FALSE, TRUE, TRUE },
    { AM_EVENT, SE_KERNEL_OBJECT, TEXT("Event"),
    TEXT("To view the access rights of an Event either enter the ")
    TEXT("object's name in the \"Name\" field, or the numerical value ")
    TEXT("of its handle and process ID in ")
    TEXT("the \"Handle\" and \"PID/TID\" fields."),
    TRUE, TRUE, TRUE, FALSE, FALSE },
    { AM_FILE, SE_FILE_OBJECT, TEXT("File"),
    TEXT("To view the access rights of a file either enter the fully ")
    TEXT("qualified path and filname in the \"Name\" field, or the ")
    TEXT("numerical value of the handle and process in the \"Handle\" ")
    TEXT("and \"PID/TID\" fields."),
    TRUE, TRUE, TRUE, TRUE, FALSE },
    { AM_MAPPING, SE_KERNEL_OBJECT, TEXT("File Mapping"),
    TEXT("To view the access rights of a file mapping either enter ")
    TEXT("the object's name in the \"Name\" field, or the numerical ")
    TEXT("value of its handle and process ID in the \"Handle\" and ")
    TEXT("\"PID/TID\" fields."),
    TRUE, TRUE, TRUE, FALSE, FALSE },
    { AM_JOB, SE_KERNEL_OBJECT, TEXT("Job"),
    TEXT("Enter the numerical value of the Job's handle and process ")
    TEXT("ID's in the \"Handle\" and \"PID/TID\" fields."),
    FALSE, TRUE, TRUE, FALSE, FALSE },
    { AM_MUTEX, SE_KERNEL_OBJECT, TEXT("Mutex"),
    TEXT("To view the access rights of a Mutex either enter the ")
    TEXT("object's name in the \"Name\" field, or the numerical value ")
    TEXT("of its handle and process ID in ")
    TEXT("the \"Handle\" and \"PID/TID\" fields."),
    TRUE, TRUE, TRUE, FALSE, FALSE },
    { AM_NAMEDPIPE, SE_KERNEL_OBJECT, TEXT("Named Pipe"),
    TEXT("To view the access rights of a Named Pipe enter the numerical ")
    TEXT("value of its handle and process ID in ")
    TEXT("the \"Handle\" and \"PID/TID\" fields."),
    FALSE, TRUE, TRUE, FALSE, FALSE },
    { AM_PRINTER, SE_PRINTER, TEXT("Printer"),
    TEXT("To view the access rights of a printer or print server enter ")
    TEXT("the object's fully qualified UNC name in the \"Name\" field."),
    TRUE, FALSE, FALSE, FALSE, FALSE },
    { AM_PROCESS, SE_KERNEL_OBJECT, TEXT("Process"),
    TEXT("Enter a Process' ID in the \"PID/TID\" field."),
    FALSE, FALSE, TRUE, FALSE, FALSE },
    { AM_REGISTRY, SE_REGISTRY_KEY, TEXT("Registry Key"),
    TEXT("To view the access rights of a registry key either enter the ")
    TEXT("fully qualified path and keyname in the \"Name\" field, or ")
    TEXT("the numerical value of the handle and process in the ")
    TEXT("\"Handle\" and \"PID/TID\" fields.  \r\nExample: \"\\\\machine")
    TEXT("name\\CLASSES_ROOT\\somepath\r\n\r\nThe following predefined ")
    TEXT("registry key values can be used:  \"CLASSES_ROOT\", \"CURRENT_")
    TEXT("USER\", \"MACHINE\", and \"USERS\"."),
    TRUE, TRUE, TRUE, TRUE, TRUE },
    { AM_SEMAPHORE, SE_KERNEL_OBJECT, TEXT("Semaphore"),
    TEXT("To view the access rights of a Semaphore either enter the ")
    TEXT("object's name in the \"Name\" field, or the numerical value ")
    TEXT("of its handle and process ID in the \"Handle\" ")
    TEXT("and \"PID/TID\" fields."),
    TRUE, TRUE, TRUE, FALSE, FALSE },
    { AM_SERVICE, SE_SERVICE, TEXT("Service"),
    TEXT("To view the access rights of a service enter the service's ")
    TEXT("programmatic name in the \"Name\" field."),
    TRUE, FALSE, FALSE, FALSE, FALSE },
    { AM_SHARE, SE_LMSHARE, TEXT("Share"),
    TEXT("Enter a network share name in the \"Name\" field.  A share ")
    TEXT("object can be local, such as \"sharename\"; or ")
    TEXT("remote, such as \"\\\\machinename\\sharename\"."),
    TRUE, FALSE, FALSE, FALSE, FALSE },
    { AM_THREAD, SE_KERNEL_OBJECT, TEXT("Thread"),
    TEXT("Enter a Thread's Thread-ID or TID in the \"PID/TID\" field"),
    FALSE, FALSE, TRUE, FALSE, FALSE },
    { AM_TIMER, SE_KERNEL_OBJECT, TEXT("Waitable Timer"),
    TEXT("To view the access rights of a Waitable Timer either enter ")
    TEXT("the object's name in the \"Name\" field, or the numerical value ")
    TEXT("of its handle and process ID in ")
    TEXT("the \"Handle\" and \"PID/TID\" fields."),
    TRUE, TRUE, TRUE, FALSE, FALSE },
    { AM_WINDOWSTATION, SE_WINDOW_OBJECT, TEXT("Window Station"),
    TEXT("To view the access rights of a Window Station either enter ")
    TEXT("the object's name in the \"Name\" field, or the numerical ")
    TEXT("value of its handle and process ID in the \"Handle\" and ")
    TEXT("\"PID/TID\" fields.\r\nExample: \"Winsta0\""),
    TRUE, TRUE, TRUE, FALSE, FALSE }
};


///////////////////////////////////////////////////////////////////////////////   


void UpdateObjDependentCtrls(HWND hwnd) {

	// Setup controls for selected object type   
	HWND hwndCtrl = GetDlgItem(hwnd, IDC_TYPE);
	int nIndex = ComboBox_GetCurSel(hwndCtrl);

	SetDlgItemText(hwnd, IDE_USAGE, g_objMap[nIndex].m_pszUsageText);

	hwndCtrl = GetDlgItem(hwnd, IDE_NAME);
	EnableWindow(hwndCtrl, g_objMap[nIndex].m_fUseName);

	hwndCtrl = GetDlgItem(hwnd, IDE_HANDLE);
	EnableWindow(hwndCtrl, g_objMap[nIndex].m_fUseHandle);

	hwndCtrl = GetDlgItem(hwnd, IDE_PID);
	EnableWindow(hwndCtrl, g_objMap[nIndex].m_fUsePID);

	if (g_objMap[nIndex].m_fUsePID || g_objMap[nIndex].m_fUseHandle) {
		hwndCtrl = GetDlgItem(hwnd, IDR_HANDLE);
		EnableWindow(hwndCtrl, TRUE);
	}
	else {
		hwndCtrl = GetDlgItem(hwnd, IDR_HANDLE);
		EnableWindow(hwndCtrl, FALSE);
		CheckRadioButton(hwnd, IDR_NAME, IDR_HANDLE, IDR_NAME);
	}

	if (g_objMap[nIndex].m_fUseName) {
		hwndCtrl = GetDlgItem(hwnd, IDR_NAME);
		EnableWindow(hwndCtrl, TRUE);
	}
	else {
		hwndCtrl = GetDlgItem(hwnd, IDR_NAME);
		EnableWindow(hwndCtrl, FALSE);
		CheckRadioButton(hwnd, IDR_NAME, IDR_HANDLE, IDR_HANDLE);
	}
}


///////////////////////////////////////////////////////////////////////////////   


BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam) {

	chSETDLGICONS(hwnd, IDI_ACCESSMASTER);

	CheckDlgButton(hwnd, IDR_NAME, BST_CHECKED);

	TCHAR szTitle[1024];
	lstrcpy(szTitle, TEXT("AccessMaster is running as \""));
	ULONG lSize = chDIMOF(szTitle) - lstrlen(szTitle);
	GetUserName(szTitle + lstrlen(szTitle), &lSize);
	lstrcat(szTitle, TEXT("\""));
	SetWindowText(hwnd, szTitle);

	// Set-up the object type combo   
	int nIndex = chDIMOF(g_objMap);
	HWND hwndCtrl = GetDlgItem(hwnd, IDC_TYPE);
	while (nIndex-- != 0) {
		ComboBox_InsertString(hwndCtrl, 0, g_objMap[nIndex].m_pszComboText);
	}

	ComboBox_SetCurSel(hwndCtrl, 0);
	UpdateObjDependentCtrls(hwnd);

	return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////   


void HandleType(HWND hwnd, UINT codeNotify, HWND hwndCtl) {

	if (codeNotify == CBN_SELCHANGE)
		UpdateObjDependentCtrls(hwnd);
}


///////////////////////////////////////////////////////////////////////////////   


void HandleRadio(HWND hwnd, UINT codeNotify, UINT nCtrl) {

	if (codeNotify == EN_SETFOCUS)
		CheckRadioButton(hwnd, IDR_NAME, IDR_HANDLE, nCtrl);
}


///////////////////////////////////////////////////////////////////////////////   


BOOL FillInfo(HWND hwnd, ObjInf* pInfo) {

	BOOL fReturn = FALSE;

	// Map object type to data block in the object map   
	HWND hwndCtrl = GetDlgItem(hwnd, IDC_TYPE);
	int nIndex = ComboBox_GetCurSel(hwndCtrl);
	pInfo->m_pEntry = g_objMap + nIndex;

	// Copy the object's name into the info block for building the title text   
	lstrcpy(pInfo->m_szObjectName, pInfo->m_pEntry->m_pszComboText);

	// Is it a named item?   
	if (IsDlgButtonChecked(hwnd, IDR_NAME)) {
		switch (pInfo->m_pEntry->m_nSpecificType) {

		case AM_WINDOWSTATION:
		{ // If windowstation, we must translate the name to a handle   
			HWINSTA hwinsta = NULL;
			GetDlgItemText(hwnd, IDE_NAME, pInfo->m_szName,
				chDIMOF(pInfo->m_szName));
			// Get the maximum possible access   
			hwinsta = OpenWindowStation(pInfo->m_szName, FALSE,
				MAXIMUM_ALLOWED);

			if (hwinsta == NULL) // Still failed?   
				ReportError(TEXT("OpenWindowStation"), GetLastError());
			else { // Otherwise finish title text   
				fReturn = TRUE;
				pInfo->m_hHandle = (HANDLE)hwinsta;
				lstrcat(pInfo->m_szObjectName, TEXT("-"));
				lstrcat(pInfo->m_szObjectName, pInfo->m_szName);
				pInfo->m_szName[0] = 0;
			}
		}
		break;

		case AM_DESKTOP:
		{ // If desktop, we must translate the name to a handle   
			HWINSTA hwinstaOld;
			HWINSTA hwinstaTemp;
			HDESK hdesk = NULL;
			PTSTR pszWinSta;
			PTSTR pszDesktop;
			int nIndex;

			GetDlgItemText(hwnd, IDE_NAME, pInfo->m_szName,
				chDIMOF(pInfo->m_szName));
			pszWinSta = pInfo->m_szName;
			nIndex = lstrlen(pInfo->m_szName);

			// Parse the text for windowstation and desktop   
			while (nIndex-- != 0) {

				if (pInfo->m_szName[nIndex] == TEXT('\\')
					|| pInfo->m_szName[nIndex] == TEXT('/')) {

					pInfo->m_szName[nIndex] = 0;
					break;
				}
			}

			// Desktop string   
			nIndex++;
			pszDesktop = pInfo->m_szName + nIndex;
			// Open the windowstation   
			hwinstaTemp = OpenWindowStation(pszWinSta, FALSE,
				DESKTOP_ENUMERATE);
			if (hwinstaTemp != NULL) {
				// Save the last one   
				hwinstaOld = GetProcessWindowStation();
				SetProcessWindowStation(hwinstaTemp);
				// Get maximum access to the desktop   
				hdesk = OpenDesktop(pszDesktop, 0, FALSE,
					MAXIMUM_ALLOWED);
				if (hdesk == NULL)// failed?   
					ReportError(TEXT("OpenDesktop"), GetLastError());
				else { // build title   
					fReturn = TRUE;
					pInfo->m_hHandle = (HANDLE)hdesk;
					lstrcat(pInfo->m_szObjectName, TEXT("-"));
					lstrcat(pInfo->m_szObjectName, pszDesktop);
					pInfo->m_szName[0] = 0;
				}

				// Close and reset window stations for the process   
				CloseWindowStation(hwinstaTemp);
				SetProcessWindowStation(hwinstaOld);

			}
			else // Failed open winsta   
				ReportError(TEXT("OpenWindowStation"), GetLastError());
		}
		break;

		default: // The rest of named objects work with GetNamedSecurity...   
			GetDlgItemText(hwnd, IDE_NAME, pInfo->m_szName,
				chDIMOF(pInfo->m_szName));
			lstrcat(pInfo->m_szObjectName, TEXT("-"));
			lstrcat(pInfo->m_szObjectName, pInfo->m_szName);
			fReturn = TRUE;
			break;
		}

	}
	else { // Is it a handle and or process id we are dealing with?   

		BOOL fTrans;
		// Get the actual numbers   
		ULONG lPid = GetDlgItemInt(hwnd, IDE_PID, &fTrans, FALSE);
		HANDLE hHandle = (HANDLE)GetDlgItemInt(hwnd, IDE_HANDLE, &fTrans,
			FALSE);
		HANDLE hObj = NULL;

		switch (pInfo->m_pEntry->m_nSpecificType) {

		case AM_THREAD: // Maximum access to the thread   
			hObj = OpenThread(MAXIMUM_ALLOWED, FALSE, lPid);
			if (hObj == NULL) // None == failure   
				ReportError(TEXT("OpenThread"), GetLastError());
			break;

		case AM_PROCESS: // Get maximum access to the process   
			hObj = OpenProcess(MAXIMUM_ALLOWED, FALSE, lPid);
			if (hObj == NULL) // None == failure   
				ReportError(TEXT("OpenProcess"), GetLastError());
			break;

		default: // The rest work with duplicate handle   
		{
			HANDLE hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, lPid);
			if (hProcess != NULL) {
				// Get as much access as possible   
				if (!DuplicateHandle(hProcess, hHandle, GetCurrentProcess(),
					&hObj, MAXIMUM_ALLOWED, FALSE, 0))
					ReportError(TEXT("DuplicateHandle"), GetLastError());
			}
			else
				ReportError(TEXT("OpenProcess"), GetLastError());
		}
		break;
		}

		if (hObj != NULL) {
			pInfo->m_hHandle = hObj;
			fReturn = TRUE;
		}
	}

	// Test object availability    
	if (fReturn) {
		ULONG lErr;
		PSECURITY_DESCRIPTOR pSD = NULL;
		if (pInfo->m_szName[0] != 0) // Is it named   
			lErr = GetNamedSecurityInfo(pInfo->m_szName,
				pInfo->m_pEntry->m_objType, DACL_SECURITY_INFORMATION,
				NULL, NULL, NULL, NULL, &pSD);
		else // Is it a handle case   
			lErr = GetSecurityInfo(pInfo->m_hHandle, pInfo->m_pEntry->m_objType,
				DACL_SECURITY_INFORMATION, NULL, NULL, NULL, NULL, &pSD);

		if ((lErr != ERROR_ACCESS_DENIED) && (lErr != ERROR_SUCCESS)) {
			ReportError(TEXT("Get[Named]SecurityInfo"), lErr);
			fReturn = FALSE;
		}
		else {
			LocalFree(pSD);
		}
	}

	return(fReturn);
}


///////////////////////////////////////////////////////////////////////////////   


///////////////////////////////////////////////////////////////////////////////   


void HandleEdit(HWND hwnd) {

	// Maintains information about the object whose security we are editing   
	ObjInf info = { 0 };

	// Fill the info structure with info from the UI   
	if (FillInfo(hwnd, &info)) {

		// Create instance of class derived from interface ISecurityInformation    
		CSecurityInformation* pSec = new CSecurityInformation(&info,
			IsDlgButtonChecked(hwnd, IDC_BINARY) == BST_CHECKED);

		// Common dialog box for ACL editing   
		EditSecurity(hwnd, pSec);
		if (pSec != NULL)
			pSec->Release();

		// Cleanup if we had opened a handle before   
		if (info.m_szName[0] == 0) {

			switch (info.m_pEntry->m_nSpecificType) {

			case AM_FILE:
			case AM_PROCESS:
			case AM_THREAD:
			case AM_JOB:
			case AM_SEMAPHORE:
			case AM_EVENT:
			case AM_MUTEX:
			case AM_MAPPING:
			case AM_TIMER:
			case AM_TOKEN:
			case AM_NAMEDPIPE:
			case AM_ANONPIPE:
				CloseHandle(info.m_hHandle);
				break;

			case AM_REGISTRY:
				RegCloseKey((HKEY)info.m_hHandle);
				break;

			case AM_WINDOWSTATION:
				CloseWindowStation((HWINSTA)info.m_hHandle);
				break;

			case AM_DESKTOP:
				CloseDesktop((HDESK)info.m_hHandle);
				break;
			}
		}
	}
}


///////////////////////////////////////////////////////////////////////////////   


void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) {

	switch (id) {

	case IDCANCEL:
		EndDialog(hwnd, 0);
		break;

	case IDC_TYPE:
		HandleType(hwnd, codeNotify, hwndCtl);
		break;

	case IDE_PID:
	case IDE_HANDLE:
		HandleRadio(hwnd, codeNotify, IDR_HANDLE);
		break;

	case IDE_NAME:
		HandleRadio(hwnd, codeNotify, IDR_NAME);
		break;

	case IDB_EDIT:
		HandleEdit(hwnd);
		break;
	}
}


///////////////////////////////////////////////////////////////////////////////   


INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

	switch (uMsg) {

		chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);
		chHANDLE_DLGMSG(hwnd, WM_COMMAND, Dlg_OnCommand);
	}
	return(FALSE);
}


///////////////////////////////////////////////////////////////////////////////   


int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR pszCmdLine, int) {

	DialogBox(hinstExe, MAKEINTRESOURCE(IDD_DIALOG), NULL, Dlg_Proc);
	return(0);
}


///////////////////////////////// End of File /////////////////////////////////  